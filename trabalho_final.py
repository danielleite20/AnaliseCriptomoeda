# -*- coding: utf-8 -*-
"""Trabalho_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lxARBqd1Um1PVHQ4jN5cxrsecovw86GC
"""

#Instalação e atualização de libs

pip install --upgrade plotly

pip install --upgrade pandas_datareader

pip install Prophet

"""Grupo 10 

*   Douglas Freitas França Chaves
*   Daniel César Silva Leite
*   André Luiz Fasano da Cunha
*   Arthur de Souza Alves

**Cripto Coins:**

Bitcoin é uma criptomoeda descentralizada, sendo um dinheiro eletrônico para transações ponto a ponto. O primeiro artigo descrevendo sua implementação ocorreu em 2008.

Bitcoin Gold trata-se de um hard fork da Bitcoin original. O objetivo principal desse hard fork foi mudar o algoritmo de prova de trabalho para que CIAEs não possam ser usados para minerar no blockchain do Bitcoin Gold.

*hard fork no contexto das criptomoedas fork ocorre quando um blockchain se divide em dois caminhos distintos que coexistem de modo paralelo.

Bitcoin Cash foi criada em 01 de agosto de 2007, também em um processo de hard fork, ela é regida por um protocolo alternativo que aumenta a capacidade de transação em comparação com o Bitcoin original.

DOGE foi criada inicialmente como uma "moeda piada" em 06 de dezembro de 2013, rapidamente ganhou sua propria comunidade chegando a uma capitalização de US$60 milhões em janeiro de 2014.

Tether é comumente chamada de moeda "estavel" porque foi desenvolvida originalmente para sempre custar US$1.00.

Decred foi lançada em 2016 também resultado de um fork da Bitcoin. Ela incorpora funções de governança usando um sistema de consenso híbrido de proof-of-stake (PoS) e proof-of-work (PoS).

NEO em sua concepção era conhecida como Antshares. O projeto foi considerado como uma "Ethereum da China". Um oferta inicial foi realizada em 8 de agosto de 2016 arrecadando US$97.51 e 8.169 BTC.

Ethereum foi fundado como um projeto crowdfunding, sendo  o terceiro maior projeto já financiado dessa forma na história e teve seu lançamento em 30 de julho de 2015.

Litecoin é inspirada e quase tecnicamente semelhante ao Bitcoin. A criação e transferência de Litecoin está baseada num protocolo de criptografia de código aberto e não é gerida por uma autoridade central.

XRP conhecida como Ripple e lançada em 2012, a Ripple baseia-se em um banco de dados publico compartilhado. Atualmente ela é a terceira maior criptomoeda do mercado após a Bitcoin e Ethereum.

#Adicionando as Bibliotecas e baixando os dados do Yahoo
"""

import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
import datetime as dt
import pandas_datareader.data as web
import plotly.express as px
import plotly.graph_objects as go
import plotly.offline as py
import matplotlib.dates as mdates
import warnings
warnings.filterwarnings('ignore')
pd.options.display.float_format = '${:,.2f}'.format

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from fbprophet import Prophet
from fbprophet.plot import plot_plotly, plot_components_plotly
from scipy import stats
from sklearn.metrics import mean_squared_error, r2_score, mean_absolute_error

#Ajusta datas para analise
start = dt.datetime(2019,11,1)
end = dt.datetime(2021,11,1)

#Baixa os dados da Yahoo atraves do pacote pandas_datareader(pacote yfinance também atende o proposito)
BTC = web.DataReader("BTC-USD", 'yahoo', start, end)
BTC.reset_index(inplace=False)

ETH = web.DataReader("ETH-USD", 'yahoo', start, end)
ETH.reset_index(inplace=False)

DOGE = web.DataReader("DOGE-USD", 'yahoo', start, end)
DOGE.reset_index(inplace=False)

THT = web.DataReader("USDT-USD", 'yahoo', start, end)
THT.reset_index(inplace=False)

BTG = web.DataReader("BTG-USD", 'yahoo', start, end)
BTG.reset_index(inplace=False)

BCH = web.DataReader("BCH-USD", 'yahoo', start, end)
BCH.reset_index(inplace=False)

DCR = web.DataReader("DCR-USD", 'yahoo', start, end)
DCR.reset_index(inplace=False)

NEO = web.DataReader("NEO-USD", 'yahoo', start, end)
NEO.reset_index(inplace=False)

LTC = web.DataReader("LTC-USD", 'yahoo', start, end)
LTC.reset_index(inplace=False)

XRP = web.DataReader("XRP-USD", 'yahoo', start, end)
XRP.reset_index(inplace=False)

BTC

#Cria um novo DataFrame somente com os valores de fechamento
crypto = BTC[['Adj Close']]
crypto = crypto.rename(columns = {'Adj Close':'BTC'})

crypto["BTG"] = BTG["Adj Close"]
crypto["BCH"] = BCH["Adj Close"]
crypto["DOGE"] = DOGE["Adj Close"]
crypto["THT"] = THT["Adj Close"]
crypto["DCR"] = DCR["Adj Close"]
crypto["NEO"] = NEO["Adj Close"]
crypto["LTC"] = LTC["Adj Close"]
crypto["XRP"] = XRP["Adj Close"]
crypto["ETH"] = ETH["Adj Close"]

crypto

#HeatMap para verificar correlação entre as moedas
plt.figure(figsize=(10,10))
sns.heatmap(crypto[['BTC', 'BTG', 'BCH','ETH', 'DOGE', 'NEO','THT','DCR','LTC','XRP']].corr(),annot=True,cmap='Blues')

crypto.describe()

#Renomeia a coluna com as criptos para melhor manejamento dos dados
crypto.columns.name = 'cripto'

px.line(crypto, facet_col="cripto", facet_col_wrap=5)

px.line(crypto, y=crypto.columns, title='Evolução das Criptos')

"""# Calcula Retorno das moedas entre outras medidas uteis para analise"""

#Calcula Retorno das criptos
Retorno = crypto.pct_change()
Retorno

px.line(Retorno, facet_col="cripto", facet_col_wrap=5)

Retorno.plot(grid=True, figsize=(15, 10)).axhline(y = 0, color = "black", lw = 2)

"""# Volatilidade da Moeda"""

#Volatilidade diaria
Retorno.std()

# Calculando volatilidade com uma janela de 30 dias
media_movel_retorno = Retorno.rolling(window=30).std()
px.line(media_movel_retorno, title='Volatilidade na janela de 30 dias')

"""# Regressão Linear e Multipla"""

def gerar_dados_l01():
  x = mdates.date2num(BTC.index)
  y = BTC['Adj Close']
  return x, y

def f_regressao_linear(x, y):  #f(x) = coef_angular * x + coef_linear
  coef_angular, coef_linear, r, p, std_err = stats.linregress(x, y)
  return coef_angular, coef_linear

def funcao_linear(x, coeficiente_angular, coeficiente_linear): 
  f = coeficiente_angular * x + coeficiente_linear
  return f

x, y = gerar_dados_l01()

coef_angular, coef_linear = f_regressao_linear(x, y)

regressao_linear = []
for w in x:
  f = funcao_linear(w, coef_angular, coef_linear)
  regressao_linear.append(f)

plt.figure(figsize = (16,8))    
plt.scatter(BTC.index, y, color = 'red')
plt.plot(x, regressao_linear, color = 'blue')
plt.title("Regressão Linear")
plt.xlabel('Data')
plt.ylabel('Moeda')
plt.show()
#print(regressao_linear)

f = funcao_linear(9, coef_angular, coef_linear)
print('f(9)={}'.format(f))

def gerar_dados_p01():
  x = mdates.date2num(BTC.index).reshape(-1,1).flatten()
  y = BTC['Adj Close'].values.reshape(-1,1).flatten()
  return x, y

def f_regressao_polinomial(x, y):
  modelo = np.poly1d(np.polyfit(x, y, 3))
  return modelo

x, y = gerar_dados_p01()

modelo = f_regressao_polinomial(x, y)


plt.figure(figsize = (16,8))
plt.scatter(BTC.index, y, color='red')
plt.plot(x, y, color='green')
plt.plot(x, modelo(x), color='blue')
plt.title("Regressão Polinomial de Grau 3")
plt.xlabel('Data')
plt.ylabel('Moeda')
plt.show()
erro=r2_score(y, modelo(x))
print('Erro de aproximação: {}'.format(erro))

"""# Aprendizado de maquina com o Prophet"""

#Primeiro resetar os indexes
BTC.reset_index(inplace=True)
ETH.reset_index(inplace=True)
DOGE.reset_index(inplace=True)
THT.reset_index(inplace=True)
BTG.reset_index(inplace=True)
BCH.reset_index(inplace=True)
DCR.reset_index(inplace=True)
NEO.reset_index(inplace=True)
LTC.reset_index(inplace=True)
XRP.reset_index(inplace=True)

BTC.info()

BTC.isnull().sum()

#Inicio do Prophet
df = BTC[["Date", "Adj Close"]]
novo = {
    "Date": "ds", 
    "Adj Close": "y",
}
df.rename(columns=novo, inplace=True)

df.tail()

x = df["ds"]
y = df["y"]
fig = go.Figure()
fig.add_trace(go.Scatter(x=x, y=y))

fig.update_layout(
    title_text="Time series do Preço de Fechamento do Bitcoin",
)

m = Prophet(
    seasonality_mode="multiplicative" 
)
m.fit(df)

#Faz uma previsão de 1 ano a partir da ultima data
futuro = m.make_future_dataframe(periods = 365)
futuro.tail()

#Cria um Data Frame com os Valores Futuros
previsao = m.predict(futuro)
previsao[['ds', 'yhat', 'yhat_lower', 'yhat_upper']].tail()
#previsao.tail()

#Cria um plot para visualizar a previsão
plot_plotly(m, previsao)